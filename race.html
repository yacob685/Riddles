also makei t have replay or restart level. also add pause menu. als oadd settings as well
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Race Master Pro: Tuner Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; -webkit-user-select: none; }
        
        /* LAYERS */
        #game-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #garage-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%); pointer-events: none; opacity: 0; transition: opacity 0.5s; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
        
        .pointer-events-auto { pointer-events: auto; }
        .hidden-panel { display: none !important; }
        .visible-panel { display: flex !important; }
        
        /* UI COMPONENTS */
        .glass-panel {
            background: rgba(15, 15, 20, 0.9);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
        }
        
        .btn-action {
            background: linear-gradient(135deg, #ff0055, #cc0000);
            box-shadow: 0 4px 15px rgba(255, 0, 85, 0.4);
            color: white;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
            border: none;
        }
        .btn-action:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(255, 0, 85, 0.6); }
        .btn-action:active { transform: translateY(0); }
        .btn-action:disabled { background: #333; color: #666; box-shadow: none; cursor: not-allowed; }

        .btn-secondary {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            color: white;
            transition: all 0.2s;
        }
        .btn-secondary:hover { background: rgba(255,255,255,0.1); }
        
        .btn-level {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            font-size: 1.2rem;
            border-radius: 0.5rem;
            transition: all 0.2s;
        }
        .btn-level.locked { background: #111; color: #333; border: 1px solid #222; cursor: not-allowed; }
        .btn-level.unlocked { background: #222; color: white; border: 1px solid #444; cursor: pointer; }
        .btn-level.unlocked:hover { background: #ff0055; border-color: #ff0055; transform: scale(1.1); box-shadow: 0 0 15px #ff0055; }
        .btn-level.completed { background: #004400; border-color: #00ff00; color: #00ff00; }

        .menu-card {
            transition: transform 0.2s, border-color 0.2s;
        }
        .menu-card:hover {
            transform: scale(1.02);
            border-color: rgba(255,255,255,0.4);
        }

        /* Garage Stats Bars */
        .stat-bar-bg { width: 100%; height: 8px; background: #222; border-radius: 4px; overflow: hidden; margin-top: 5px; }
        .stat-bar-fill { height: 100%; background: linear-gradient(90deg, #00d2ff, #3a7bd5); transition: width 0.5s ease-out; }

        /* Animations */
        @keyframes pulse-border { 0% { border-color: rgba(255,0,85,0.5); } 50% { border-color: rgba(255,0,85,1); } 100% { border-color: rgba(255,0,85,0.5); } }
        .border-pulse { animation: pulse-border 2s infinite; }
        
        .currency-display { font-family: 'Courier New', monospace; color: #ffd700; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
        
        /* Scrollbar for levels */
        .level-grid::-webkit-scrollbar { width: 8px; }
        .level-grid::-webkit-scrollbar-track { background: #111; }
        .level-grid::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
        .level-grid::-webkit-scrollbar-thumb:hover { background: #555; }

        /* Pedal Animations */
        .pedal-active { transform: scale(0.95); filter: brightness(1.2); }
    </style>
</head>
<body>

    <!-- 3D Containers -->
    <div id="game-layer"></div>
    <div id="garage-layer"><canvas id="garage-canvas"></canvas></div>

    <!-- UI Layer -->
    <div id="ui-layer" class="flex flex-col justify-center items-center font-sans">
        
        <!-- TOP BAR (Global) -->
        <div id="top-bar" class="absolute top-0 left-0 w-full p-4 flex justify-between items-start z-50 pointer-events-none hidden">
            <div class="glass-panel px-4 py-2 rounded-full flex items-center gap-3 pointer-events-auto">
                <span class="text-xs text-gray-400 font-bold">DRIVER</span>
                <span id="top-bar-name" class="text-white font-bold">Guest</span>
            </div>
            <div class="glass-panel px-4 py-2 rounded-full flex items-center gap-2 pointer-events-auto">
                <span class="text-yellow-400 text-xl">‚ö°</span>
                <span id="top-bar-cash" class="currency-display text-xl font-bold">0</span>
            </div>
        </div>

        <!-- 1. AUTH / LOADING -->
        <div id="loading-panel" class="absolute inset-0 bg-black flex flex-col items-center justify-center pointer-events-auto z-50">
            <h1 class="text-6xl font-black text-white italic tracking-tighter transform -skew-x-12 mb-2">RACE<span class="text-red-600">MASTER</span></h1>
            <h2 class="text-xl text-gray-500 font-light tracking-widest uppercase mb-8">Tuner Edition</h2>
            <div class="w-16 h-16 border-4 border-red-600 border-t-transparent rounded-full animate-spin"></div>
            <p id="loading-text" class="text-gray-500 mt-4 text-sm animate-pulse">Initializing Engine...</p>
        </div>

        <!-- 2. MAIN MENU -->
        <div id="menu-panel" class="hidden-panel absolute inset-0 flex flex-col items-center justify-center pointer-events-auto bg-black/40 backdrop-blur-sm z-40">
            <div class="w-full max-w-6xl px-6">
                <div class="text-center mb-10">
                    <h1 class="text-6xl font-black text-white italic tracking-tighter transform -skew-x-6 drop-shadow-2xl">SELECT <span class="text-transparent bg-clip-text bg-gradient-to-r from-red-500 to-orange-500">MODE</span></h1>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-4 gap-6">
                    
                    <!-- Tab 1: Solo -->
                    <button id="btn-mode-solo" class="menu-card group relative h-80 glass-panel rounded-2xl p-6 text-left border border-gray-700 hover:border-blue-500 flex flex-col justify-between overflow-hidden">
                        <div class="absolute inset-0 bg-blue-900/20 group-hover:bg-blue-900/40 transition-colors z-0"></div>
                        <div class="relative z-10">
                            <span class="text-5xl mb-4 block">üèéÔ∏è</span>
                            <h2 class="text-3xl font-black text-white italic">SOLO<br>RACE</h2>
                            <p class="text-gray-400 text-sm mt-2">Versus 4 Bots. 100 Levels.</p>
                            <div class="mt-4 inline-block bg-black/50 px-3 py-1 rounded text-xs border border-blue-500/30 text-blue-300">
                                Current Level: <span id="menu-level-display" class="font-bold text-white">1</span>
                            </div>
                        </div>
                        <div class="relative z-10 mt-auto">
                            <span class="text-blue-400 font-bold tracking-widest text-xs uppercase group-hover:underline">Select Level &rarr;</span>
                        </div>
                    </button>

                    <!-- Tab 2: Multiplayer -->
                    <button id="btn-mode-multi" class="menu-card group relative h-80 glass-panel rounded-2xl p-6 text-left border border-gray-700 hover:border-red-500 flex flex-col justify-between overflow-hidden">
                        <div class="absolute inset-0 bg-red-900/20 group-hover:bg-red-900/40 transition-colors z-0"></div>
                        <div class="relative z-10">
                            <span class="text-5xl mb-4 block">üåê</span>
                            <h2 class="text-3xl font-black text-white italic">ONLINE<br>PVP</h2>
                            <p class="text-gray-400 text-sm mt-2">Race against real players in real-time lobbies.</p>
                        </div>
                        <div class="relative z-10 mt-auto">
                            <span class="text-red-400 font-bold tracking-widest text-xs uppercase group-hover:underline">Enter Lobby &rarr;</span>
                        </div>
                    </button>

                    <!-- Tab 3: Garage -->
                    <button id="btn-mode-garage" class="menu-card group relative h-80 glass-panel rounded-2xl p-6 text-left border border-gray-700 hover:border-yellow-500 flex flex-col justify-between overflow-hidden">
                        <div class="absolute inset-0 bg-yellow-900/20 group-hover:bg-yellow-900/40 transition-colors z-0"></div>
                        <div class="relative z-10">
                            <span class="text-5xl mb-4 block">üîß</span>
                            <h2 class="text-3xl font-black text-white italic">MY<br>GARAGE</h2>
                            <p class="text-gray-400 text-sm mt-2">Upgrade stats and customize your ride.</p>
                        </div>
                        <div class="relative z-10 mt-auto">
                            <span class="text-yellow-400 font-bold tracking-widest text-xs uppercase group-hover:underline">Tune Up &rarr;</span>
                        </div>
                    </button>

                    <!-- Tab 4: Shop -->
                    <button id="btn-mode-shop" class="menu-card group relative h-80 glass-panel rounded-2xl p-6 text-left border border-gray-700 hover:border-green-500 flex flex-col justify-between overflow-hidden">
                        <div class="absolute inset-0 bg-green-900/20 group-hover:bg-green-900/40 transition-colors z-0"></div>
                        <div class="relative z-10">
                            <span class="text-5xl mb-4 block">üíé</span>
                            <h2 class="text-3xl font-black text-white italic">PREMIUM<br>SHOP</h2>
                            <p class="text-gray-400 text-sm mt-2">Boost your progress with exclusive packs.</p>
                        </div>
                        <div class="relative z-10 mt-auto">
                            <span class="text-green-400 font-bold tracking-widest text-xs uppercase group-hover:underline">Browse Offers &rarr;</span>
                        </div>
                    </button>

                </div>
            </div>
        </div>

        <!-- 2.5 LEVEL SELECT -->
        <div id="level-select-panel" class="hidden-panel absolute inset-0 flex items-center justify-center bg-black/90 pointer-events-auto z-40">
            <div class="glass-panel p-8 rounded-2xl w-full max-w-4xl h-[80vh] flex flex-col">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-4xl font-black text-white italic">CAMPAIGN MODE</h2>
                    <button id="btn-level-back" class="btn-secondary px-6 py-2 rounded-lg font-bold">BACK</button>
                </div>
                
                <div id="level-grid" class="level-grid grid grid-cols-5 md:grid-cols-8 gap-3 overflow-y-auto p-2 flex-grow">
                    <!-- JS Injects Buttons Here -->
                </div>
            </div>
        </div>

        <!-- 3. GARAGE -->
        <div id="garage-panel" class="hidden-panel absolute inset-0 flex flex-col justify-between p-6 pointer-events-none z-40">
            <!-- Left: Stats -->
            <div class="glass-panel p-6 rounded-xl w-full max-w-xs pointer-events-auto self-start mt-16 transform -skew-x-2">
                <h3 class="text-xl font-black text-white italic mb-4 border-b border-gray-700 pb-2">PERFORMANCE</h3>
                
                <div class="space-y-4">
                    <!-- Speed -->
                    <div>
                        <div class="flex justify-between text-xs font-bold text-gray-400 uppercase mb-1">
                            <span>Top Speed</span>
                            <span class="text-white" id="stat-val-speed">100</span>
                        </div>
                        <div class="stat-bar-bg"><div id="bar-speed" class="stat-bar-fill" style="width: 20%"></div></div>
                        <button id="btn-upg-speed" class="mt-2 w-full py-2 bg-gray-800 hover:bg-gray-700 border border-gray-600 text-white text-xs font-bold rounded flex justify-between px-3">
                            <span>UPGRADE</span>
                            <span class="text-yellow-400">$<span id="cost-speed">500</span></span>
                        </button>
                    </div>

                    <!-- Accel -->
                    <div>
                        <div class="flex justify-between text-xs font-bold text-gray-400 uppercase mb-1">
                            <span>Acceleration</span>
                            <span class="text-white" id="stat-val-accel">100</span>
                        </div>
                        <div class="stat-bar-bg"><div id="bar-accel" class="stat-bar-fill" style="width: 20%"></div></div>
                        <button id="btn-upg-accel" class="mt-2 w-full py-2 bg-gray-800 hover:bg-gray-700 border border-gray-600 text-white text-xs font-bold rounded flex justify-between px-3">
                            <span>UPGRADE</span>
                            <span class="text-yellow-400">$<span id="cost-accel">500</span></span>
                        </button>
                    </div>

                    <!-- Handling -->
                    <div>
                        <div class="flex justify-between text-xs font-bold text-gray-400 uppercase mb-1">
                            <span>Handling</span>
                            <span class="text-white" id="stat-val-hand">100</span>
                        </div>
                        <div class="stat-bar-bg"><div id="bar-hand" class="stat-bar-fill" style="width: 20%"></div></div>
                        <button id="btn-upg-hand" class="mt-2 w-full py-2 bg-gray-800 hover:bg-gray-700 border border-gray-600 text-white text-xs font-bold rounded flex justify-between px-3">
                            <span>UPGRADE</span>
                            <span class="text-yellow-400">$<span id="cost-hand">500</span></span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Bottom: Paint & Back -->
            <div class="flex justify-between items-end w-full pointer-events-auto">
                <div class="glass-panel p-4 rounded-xl flex gap-2">
                    <button class="w-10 h-10 rounded-full border-2 border-white/20 hover:scale-110 transition-transform bg-red-600" onclick="setCarColor('#ff0000')"></button>
                    <button class="w-10 h-10 rounded-full border-2 border-white/20 hover:scale-110 transition-transform bg-blue-600" onclick="setCarColor('#0066ff')"></button>
                    <button class="w-10 h-10 rounded-full border-2 border-white/20 hover:scale-110 transition-transform bg-green-500" onclick="setCarColor('#00ff44')"></button>
                    <button class="w-10 h-10 rounded-full border-2 border-white/20 hover:scale-110 transition-transform bg-yellow-400" onclick="setCarColor('#ffcc00')"></button>
                    <button class="w-10 h-10 rounded-full border-2 border-white/20 hover:scale-110 transition-transform bg-purple-600" onclick="setCarColor('#9900ff')"></button>
                    <button class="w-10 h-10 rounded-full border-2 border-white/20 hover:scale-110 transition-transform bg-white" onclick="setCarColor('#ffffff')"></button>
                    <button class="w-10 h-10 rounded-full border-2 border-white/20 hover:scale-110 transition-transform bg-gray-900" onclick="setCarColor('#111111')"></button>
                </div>

                <button id="btn-exit-garage" class="btn-secondary px-8 py-3 rounded-xl font-bold uppercase tracking-wider">
                    Save & Back
                </button>
            </div>
        </div>

        <!-- 4. LOBBY -->
        <div id="lobby-panel" class="hidden-panel absolute inset-0 flex items-center justify-center bg-black/80 backdrop-blur pointer-events-auto z-40">
            <div class="glass-panel p-8 rounded-2xl w-full max-w-md text-center border border-gray-700">
                <h2 class="text-3xl font-black text-white italic mb-6">MULTIPLAYER LOBBY</h2>
                
                <div class="grid grid-cols-2 gap-4 mb-6">
                    <button id="tab-create" class="p-4 rounded-xl bg-gray-800 border-2 border-red-600 text-white">Create Room</button>
                    <button id="tab-join" class="p-4 rounded-xl bg-gray-900 border border-gray-700 text-gray-400">Join Room</button>
                </div>

                <!-- Create Mode -->
                <div id="view-create" class="space-y-4">
                    <p class="text-gray-400 text-sm">Host a private race for your friends.</p>
                    <button id="btn-create-room" class="btn-action w-full py-3 rounded-xl">Generate Room Code</button>
                </div>

                <!-- Join Mode -->
                <div id="view-join" class="hidden space-y-4">
                    <input type="text" id="input-room-code" class="w-full bg-black border border-gray-600 rounded-lg p-3 text-center text-xl font-mono text-white uppercase placeholder-gray-600 focus:border-red-500 outline-none" placeholder="CODE" maxlength="4">
                    <button id="btn-join-room" class="btn-action w-full py-3 rounded-xl">Enter Room</button>
                </div>

                <button id="btn-lobby-back" class="mt-6 text-gray-500 text-sm hover:text-white underline">Back to Menu</button>
            </div>
        </div>

        <!-- 5. WAITING ROOM -->
        <div id="waiting-panel" class="hidden-panel absolute inset-0 flex items-center justify-center bg-black/90 pointer-events-auto z-40">
            <div class="glass-panel p-8 rounded-2xl w-full max-w-lg text-center">
                <div class="text-xs text-gray-400 font-bold uppercase mb-1">Room Code</div>
                <div id="display-room-code" class="text-6xl font-mono font-bold text-white mb-8 tracking-wider select-all cursor-pointer">????</div>
                
                <div class="text-left mb-8">
                    <h4 class="text-xs font-bold text-gray-500 uppercase mb-3">Racers</h4>
                    <div id="player-list" class="space-y-2">
                        <!-- Player items injected here -->
                    </div>
                </div>

                <div id="host-controls" class="hidden">
                    <button id="btn-start-race" class="btn-action w-full py-4 rounded-xl text-lg animate-pulse">START ENGINE</button>
                </div>
                <div id="guest-controls">
                    <p class="text-yellow-500 font-mono text-sm">WAITING FOR HOST...</p>
                </div>
            </div>
        </div>

        <!-- HUD -->
        <div id="hud-panel" class="hidden-panel w-full h-full relative pointer-events-none z-30">
            <!-- Speedometer -->
            <div class="absolute bottom-6 right-6 glass-panel rounded-full w-32 h-32 flex flex-col items-center justify-center border-4 border-gray-800">
                <span id="hud-speed" class="text-4xl font-black text-white italic">0</span>
                <span class="text-xs text-gray-400 font-bold">KM/H</span>
            </div>
            
            <!-- Boost Button/Meter -->
            <div class="absolute bottom-6 right-44 pointer-events-auto">
                <button id="btn-boost" class="glass-panel rounded-xl px-6 py-4 w-48 hover:bg-white/10 active:scale-95 transition-all group border-red-500/50">
                    <div class="flex justify-between items-center mb-1">
                        <span class="text-xs text-gray-400 font-bold uppercase group-hover:text-white">NITRO</span>
                        <span id="boost-status" class="text-xs font-bold text-yellow-500">CHECKING</span>
                    </div>

                    <div class="w-full h-4 bg-gray-800 rounded-full overflow-hidden border border-gray-700 relative">
                        <div id="boost-bar" class="h-full bg-gradient-to-r from-red-500 to-yellow-500 w-full animate-pulse"></div>
                    </div>
                    <div class="text-center mt-2 text-[10px] text-gray-500 font-mono uppercase">SPACE to ACTIVATE</div>
                </button>
            </div>

            <!-- ADDED: Reverse/Brake Button -->
            <div class="absolute bottom-6 left-6 pointer-events-auto">
                <button id="btn-reverse" class="glass-panel rounded-xl px-6 py-6 w-32 flex flex-col items-center justify-center border-gray-600/50 hover:bg-white/10 active:scale-95 transition-all">
                    <span class="text-3xl mb-1">üõë</span>
                    <span class="text-xs text-gray-400 font-bold uppercase">BRAKE/REV</span>
                </button>
            </div>

            <!-- Pos -->
            <div class="absolute top-20 left-4 glass-panel px-4 py-2 rounded-lg">
                <span class="text-gray-400 text-xs font-bold block">POS</span>
                <span id="hud-pos" class="text-2xl font-black text-white">1/5</span>
            </div>

            <!-- Level (Solo Only) -->
            <div id="hud-level-display" class="absolute top-20 right-4 glass-panel px-4 py-2 rounded-lg text-right hidden">
                <span class="text-gray-400 text-xs font-bold block">LEVEL</span>
                <span id="current-level-hud" class="text-2xl font-black text-blue-400">1</span>
            </div>
            
            <!-- Controls Hint -->
            <div class="absolute bottom-10 left-0 w-full text-center opacity-40">
                <p class="text-white text-sm font-bold shadow-black drop-shadow-md">HOLD TO GAS ‚Ä¢ SLIDE TO STEER</p>
            </div>

            <!-- Countdown -->
            <div id="countdown-overlay" class="absolute inset-0 flex items-center justify-center hidden">
                <span id="countdown-text" class="text-9xl font-black text-white italic drop-shadow-[0_10px_10px_rgba(0,0,0,0.8)]">3</span>
            </div>
        </div>

        <!-- AD / MONEY OVERLAY -->
        <div id="ad-overlay" class="hidden-panel absolute inset-0 bg-black/80 flex items-center justify-center z-[100] pointer-events-auto">
            <div class="glass-panel p-8 rounded-2xl max-w-sm text-center border-2 border-yellow-500">
                <h3 class="text-3xl font-black text-white italic mb-2">OUT OF CASH!</h3>
                <p class="text-gray-300 mb-6">You need <span class="text-yellow-400 font-bold">$500</span> for Nitro.</p>
                
                <div id="ad-content">
                    <button id="btn-watch-ad" class="w-full py-4 bg-yellow-600 hover:bg-yellow-500 text-white font-bold rounded-xl shadow-lg shadow-yellow-500/20 mb-3 flex items-center justify-center gap-2">
                        <span>üì∫ WATCH AD</span>
                        <span class="bg-black/20 px-2 rounded text-sm">+$600</span>
                    </button>
                    <button id="btn-close-ad" class="text-gray-500 text-xs underline hover:text-white">No Thanks (Continue Slow)</button>
                </div>
                
                <div id="ad-loading" class="hidden flex-col items-center">
                    <div class="w-10 h-10 border-4 border-yellow-500 border-t-transparent rounded-full animate-spin mb-2"></div>
                    <span class="text-yellow-500 text-sm font-bold animate-pulse">PLAYING AD...</span>
                </div>
            </div>
        </div>

        <!-- PREMIUM SHOP OVERLAY -->
        <div id="shop-overlay" class="hidden-panel absolute inset-0 bg-black/90 flex items-center justify-center z-[100] pointer-events-auto">
            <div class="glass-panel p-8 rounded-2xl max-w-2xl w-full border-2 border-yellow-500">
                <h2 class="text-4xl font-black text-white italic mb-6 text-center">
                    PREMIUM <span class="text-yellow-400">SHOP</span>
                </h2>
                
                <div class="grid grid-cols-2 gap-4 mb-6">
                    <!-- Starter Pack -->
                    <div class="bg-gradient-to-br from-blue-900 to-blue-700 p-6 rounded-xl border-2 border-blue-400">
                        <div class="text-center mb-4">
                            <div class="text-5xl mb-2">üíé</div>
                            <h3 class="text-xl font-bold text-white">Starter Pack</h3>
                        </div>
                        <div class="text-center mb-4">
                            <div class="text-3xl font-black text-yellow-400">$5,000</div>
                            <div class="text-sm text-gray-300">In-Game Cash</div>
                            <div class="text-xs text-blue-300 mt-2">+ 10 Nitro Boosts</div>
                        </div>
                        <button class="btn-action w-full py-3 text-sm" onclick="purchaseOffer('starter')">
                            BUY FOR $4.99
                        </button>
                    </div>
                    
                    <!-- Pro Pack -->
                    <div class="bg-gradient-to-br from-purple-900 to-purple-700 p-6 rounded-xl border-2 border-purple-400">
                        <div class="text-center mb-4">
                            <div class="text-5xl mb-2">üèÜ</div>
                            <h3 class="text-xl font-bold text-white">Pro Pack</h3>
                        </div>
                        <div class="text-center mb-4">
                            <div class="text-3xl font-black text-yellow-400">$15,000</div>
                            <div class="text-sm text-gray-300">In-Game Cash</div>
                            <div class="text-xs text-purple-300 mt-2">+ 30 Nitro</div>
                        </div>
                        <button class="btn-action w-full py-3 text-sm" onclick="purchaseOffer('pro')">
                            BUY FOR $9.99
                        </button>
                    </div>
                    
                    <!-- Ultimate Pack -->
                    <div class="bg-gradient-to-br from-red-900 to-orange-700 p-6 rounded-xl border-2 border-red-400 col-span-2">
                        <div class="text-center mb-4">
                            <div class="text-5xl mb-2">üëë</div>
                            <h3 class="text-2xl font-bold text-white">Ultimate Champion</h3>
                        </div>
                        <div class="text-center mb-4">
                            <div class="text-4xl font-black text-yellow-400">$50,000</div>
                            <div class="text-sm text-gray-300">In-Game Cash</div>
                            <div class="text-xs text-orange-300 mt-2">+ 100 Nitro + All Upgrades + Skip to Level 50</div>
                        </div>
                        <button class="btn-action w-full py-4 text-lg" onclick="purchaseOffer('ultimate')">
                            BUY FOR $19.99
                        </button>
                    </div>
                    
                    <!-- Nitro Only -->
                    <div class="bg-gray-800 p-4 rounded-xl border border-gray-600 col-span-2">
                        <div class="flex justify-between items-center">
                            <div>
                                <h4 class="text-white font-bold">Quick Nitro Refill</h4>
                                <p class="text-xs text-gray-400">50 Nitro Boosts</p>
                            </div>
                            <button class="bg-yellow-600 hover:bg-yellow-500 px-6 py-2 rounded font-bold" onclick="purchaseOffer('nitro')">
                                $1.99
                            </button>
                        </div>
                    </div>
                </div>
                
                <button id="btn-close-shop" class="w-full py-3 bg-gray-700 hover:bg-gray-600 rounded-xl text-white font-bold">
                    CLOSE
                </button>
            </div>
        </div>

        <!-- RESULTS -->
        <div id="result-panel" class="hidden-panel absolute inset-0 flex items-center justify-center bg-black/80 z-50 pointer-events-auto">
            <div class="glass-panel p-10 rounded-2xl text-center transform scale-110 border-t-4 border-yellow-500">
                <div id="result-title" class="text-5xl font-black text-white italic mb-2">FINISH!</div>
                <div class="text-2xl text-gray-300 mb-4">Position: <span id="result-pos" class="text-white font-bold">#1</span></div>
                <div class="bg-yellow-500/20 text-yellow-400 p-4 rounded-lg mb-6 border border-yellow-500/50">
                    <div class="text-xs font-bold uppercase">Prize Money</div>
                    <div class="text-3xl font-bold font-mono">+$<span id="result-money">0</span></div>
                </div>
                <div id="level-up-msg" class="hidden text-blue-400 font-bold mb-4 text-xl animate-bounce">LEVEL COMPLETED!</div>
                <button onclick="location.reload()" class="btn-secondary px-8 py-3 rounded-full">Return to Garage</button>
            </div>
        </div>
    </div>

    <!-- Firebase Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, getDoc, onSnapshot, updateDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-firestore.js";

        // ==========================================
        // 1. CONFIG & STATE
        // ==========================================
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'race-master-default';
        
        const firebaseConfig = {
            apiKey: "AIzaSyB-3kAk-lMT3jTny2YIs2R1_0mG-tJlmJI",
            authDomain: "puzzlesapp.firebaseapp.com",
            databaseURL: "https://puzzlesapp-default-rtdb.firebaseio.com",
            projectId: "puzzlesapp",
            storageBucket: "puzzlesapp.firebasestorage.app",
            messagingSenderId: "303461259730",
            appId: "1:303461259730:web:a1790a976b6d58d71dd00b",
            measurementId: "G-8YEJEBX0NE"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // Player Profile State
        let userProfile = {
            uid: null,
            name: 'Racer' + Math.floor(Math.random() * 999),
            cash: 1000,
            color: '#ff0055',
            stats: {
                speed: 1,
                accel: 1,
                handling: 1
            },
            currentLevel: 1,
            nitroStock: 0
        };

        const UPGRADE_COST_BASE = 500;
        const MAX_LEVEL = 10;
        const BOOST_COST = 500;
        const AD_REWARD = 600;

        // Game State
        let currentRoomId = null;
        let isHost = false;
        let isSinglePlayer = false; 
        let currentSelectedLevel = 1;
        let roomUnsubscribe = null;
        let playersMap = {}; 
        let bots = [];
        let gameStatus = 'menu';

        // 3D Globals
        let scene, camera, renderer;
        let garageScene, garageCamera, garageRenderer, garageCar;
        let myCar;
        let opponentCars = {};
        let trackGroup, obstacles = [];
        let trackPath = []; // Stores centerline data for physics
        let clock = new THREE.Clock();
        let carHeading = 0; // Car's actual facing direction in radians
        let carVelocityX = 0; // Velocity components for smoother physics
        let carVelocityZ = 0;

        // Physics Constants
        let phys = {
            maxSpeed: 1.0,
            accel: 0.01,
            turnSpeed: 0.1
        };
        let currentSpeed = 0;
        let isRespawning = false;
        
        // Revised Input State for smooth controls
        let keysPressed = {
            up: false,
            down: false,
            left: false,
            right: false
        };
        let inputState = { holding: false, steer: 0 };
        
        // Boost System
        let boostActive = false;
        let boostCooldown = 0;
        const BOOST_DURATION = 120;
        const BOOST_MULTIPLIER = 2.2; 
        const TRACK_W = 40;

        // ==========================================
        // 2. AUTH & PROFILE MANAGER
        // ==========================================
        
        async function initAuth() {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (e) {
                console.warn("Auth failed, falling back to anonymous:", e);
                await signInAnonymously(auth);
            }
        }

        onAuthStateChanged(auth, async (user) => {
            if (user) {
                userProfile.uid = user.uid;
                try {
                    await loadProfile();
                    updateUI();
                    initGarage3D();
                    document.getElementById('loading-panel').classList.add('hidden-panel');
                    document.getElementById('menu-panel').classList.remove('hidden-panel');
                    document.getElementById('top-bar').classList.remove('hidden');
                } catch (e) {
                    console.error("Profile load error:", e);
                    document.getElementById('loading-text').innerText = "Error loading profile...";
                }
            } else {
                console.warn("No authenticated user");
                document.getElementById('loading-text').innerText = "Authentication failed...";
            }
        });

        async function loadProfile() {
            const ref = doc(db, 'artifacts', appId, 'users', userProfile.uid);
            try {
                const snap = await getDoc(ref);
                if (snap.exists()) {
                    const data = snap.data();
                    userProfile.name = data.name || userProfile.name;
                    userProfile.cash = data.cash !== undefined ? data.cash : 1000;
                    userProfile.color = data.color || '#ff0055';
                    userProfile.currentLevel = data.currentLevel || 1;
                    userProfile.nitroStock = data.nitroStock !== undefined ? data.nitroStock : 0;
                    if (data.stats) userProfile.stats = data.stats;
                } else {
                    await saveProfile();
                }
            } catch (e) { console.error("Load Error", e); }
        }

        async function saveProfile() {
            const ref = doc(db, 'artifacts', appId, 'users', userProfile.uid);
            await setDoc(ref, {
                name: userProfile.name,
                cash: userProfile.cash,
                color: userProfile.color,
                stats: userProfile.stats,
                currentLevel: userProfile.currentLevel,
                nitroStock: userProfile.nitroStock
            });
            updateUI();
        }

        // ==========================================
        // 3. CAR GENERATOR
        // ==========================================
        
        function createDetailedCar(colorHex) {
            const carGroup = new THREE.Group();
            const mainColor = new THREE.Color(colorHex);
            const blackMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.5 });
            const bodyMat = new THREE.MeshStandardMaterial({ color: mainColor, metalness: 0.6, roughness: 0.2 });
            const glassMat = new THREE.MeshStandardMaterial({ color: 0x000000, metalness: 0.9, roughness: 0.1 });
            const lightMat = new THREE.MeshBasicMaterial({ color: 0xffffaa });
            const tailLightMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });

            const chassisGeo = new THREE.BoxGeometry(2, 0.5, 4.2);
            const chassis = new THREE.Mesh(chassisGeo, bodyMat);
            chassis.position.y = 0.5;
            chassis.castShadow = true;
            carGroup.add(chassis);

            const cockpitGeo = new THREE.BoxGeometry(1.6, 0.4, 2);
            const cockpit = new THREE.Mesh(cockpitGeo, glassMat);
            cockpit.position.set(0, 0.9, -0.2);
            carGroup.add(cockpit);

            const scoopGeo = new THREE.BoxGeometry(1, 0.1, 1);
            const scoop = new THREE.Mesh(scoopGeo, bodyMat);
            scoop.position.set(0, 0.76, 1.2);
            carGroup.add(scoop);

            const spoilerWingGeo = new THREE.BoxGeometry(2.2, 0.1, 0.5);
            const spoilerWing = new THREE.Mesh(spoilerWingGeo, bodyMat);
            spoilerWing.position.set(0, 1.2, -1.9);
            carGroup.add(spoilerWing);

            const spoilerPostGeo = new THREE.BoxGeometry(0.1, 0.4, 0.1);
            const p1 = new THREE.Mesh(spoilerPostGeo, blackMat); p1.position.set(0.8, 0.9, -1.9);
            const p2 = new THREE.Mesh(spoilerPostGeo, blackMat); p2.position.set(-0.8, 0.9, -1.9);
            carGroup.add(p1); carGroup.add(p2);

            const wheelGeo = new THREE.CylinderGeometry(0.45, 0.45, 0.3, 24);
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const rimGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.31, 8);
            const rimMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8 });

            const wheelPositions = [
                { x: 1.1, z: 1.3 }, { x: -1.1, z: 1.3 },
                { x: 1.1, z: -1.3 }, { x: -1.1, z: -1.3 }
            ];

            wheelPositions.forEach(pos => {
                const w = new THREE.Group();
                const tire = new THREE.Mesh(wheelGeo, wheelMat);
                const rim = new THREE.Mesh(rimGeo, rimMat);
                tire.rotation.z = Math.PI / 2;
                rim.rotation.z = Math.PI / 2;
                w.add(tire);
                w.add(rim);
                w.position.set(pos.x, 0.45, pos.z);
                carGroup.add(w);
            });

            const headLightGeo = new THREE.PlaneGeometry(0.4, 0.2);
            const hl1 = new THREE.Mesh(headLightGeo, lightMat);
            hl1.position.set(0.6, 0.6, 2.11);
            carGroup.add(hl1);
            const hl2 = hl1.clone();
            hl2.position.set(-0.6, 0.6, 2.11);
            carGroup.add(hl2);

            const tailLightGeo = new THREE.PlaneGeometry(0.4, 0.15);
            const tl1 = new THREE.Mesh(tailLightGeo, tailLightMat);
            tl1.position.set(0.6, 0.6, -2.11);
            tl1.rotation.y = Math.PI;
            carGroup.add(tl1);
            const tl2 = tl1.clone();
            tl2.position.set(-0.6, 0.6, -2.11);
            carGroup.add(tl2);

            return carGroup;
        }

        // ==========================================
        // 4. GARAGE SYSTEM
        // ==========================================

        function initGarage3D() {
            const canvas = document.getElementById('garage-canvas');
            garageScene = new THREE.Scene();
            
            garageCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            garageCamera.position.set(5, 3, 5);
            garageCamera.lookAt(0, 0.5, 0);

            garageRenderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
            garageRenderer.setSize(window.innerWidth, window.innerHeight);
            garageRenderer.setPixelRatio(window.devicePixelRatio);
            garageRenderer.shadowMap.enabled = true;

            const ambient = new THREE.AmbientLight(0xffffff, 0.5);
            garageScene.add(ambient);
            const spot = new THREE.SpotLight(0xffffff, 2);
            spot.position.set(5, 10, 5);
            spot.castShadow = true;
            garageScene.add(spot);
            
            const rimLight = new THREE.PointLight(0x00d2ff, 1);
            rimLight.position.set(-5, 2, -5);
            garageScene.add(rimLight);

            const floorGeo = new THREE.CircleGeometry(4, 32);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.5, roughness: 0.1 });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            garageScene.add(floor);

            updateGarageCar();
            animateGarage();
        }

        function updateGarageCar() {
            if (garageCar) garageScene.remove(garageCar);
            garageCar = createDetailedCar(userProfile.color);
            garageCar.position.y = 0;
            garageScene.add(garageCar);
        }

        function animateGarage() {
            if (gameStatus === 'garage') {
                requestAnimationFrame(animateGarage);
                if (garageCar) garageCar.rotation.y += 0.005;
                garageRenderer.render(garageScene, garageCamera);
            }
        }

        window.setCarColor = (c) => {
            userProfile.color = c;
            updateGarageCar();
        };

        function buyUpgrade(type) {
            const level = userProfile.stats[type];
            if (level >= MAX_LEVEL) return;
            
            const cost = UPGRADE_COST_BASE * level;
            if (userProfile.cash >= cost) {
                userProfile.cash -= cost;
                userProfile.stats[type]++;
                updateUI();
                const btn = document.getElementById(`btn-upg-${type}`);
                btn.classList.add('border-pulse');
                setTimeout(() => btn.classList.remove('border-pulse'), 500);
            } else {
                alert("Not enough cash!");
            }
        }

        // ==========================================
        // 5. UI CONTROLLER
        // ==========================================
        function updateUI() {
            document.getElementById('top-bar-name').innerText = userProfile.name;
            document.getElementById('top-bar-cash').innerText = userProfile.cash;
            document.getElementById('menu-level-display').innerText = userProfile.currentLevel;

            const stats = ['speed', 'accel', 'hand']; 
            const map = { speed: 'speed', accel: 'accel', hand: 'handling' };
            
            stats.forEach(key => {
                const lvl = userProfile.stats[map[key]];
                const pct = (lvl / MAX_LEVEL) * 100;
                const cost = UPGRADE_COST_BASE * lvl;
                
                document.getElementById(`stat-val-${key}`).innerText = `LVL ${lvl}`;
                document.getElementById(`bar-${key}`).style.width = `${pct}%`;
                
                const btn = document.getElementById(`btn-upg-${key}`);
                const costSpan = document.getElementById(`cost-${key}`);
                
                if (lvl >= MAX_LEVEL) {
                    btn.disabled = true;
                    btn.innerHTML = `<span class="text-gray-500">MAXED</span>`;
                } else {
                    btn.disabled = userProfile.cash < cost;
                    costSpan.innerText = cost;
                }
            });

            const boostStatus = document.getElementById('boost-status');
            const boostBtn = document.getElementById('btn-boost');
            if (userProfile.nitroStock > 0) {
                boostStatus.innerText = `READY x${userProfile.nitroStock}`;
                boostStatus.className = "text-xs font-bold text-green-400";
                boostBtn.classList.remove("border-red-500/50");
                boostBtn.classList.add("border-green-500/50");
            } else {
                boostStatus.innerText = `BUY 3: -$500`;
                boostStatus.className = "text-xs font-bold text-yellow-500";
                boostBtn.classList.add("border-red-500/50");
                boostBtn.classList.remove("border-green-500/50");
            }
        }
        
        // --- LEVEL SELECT LOGIC ---
        function renderLevelSelect() {
            const grid = document.getElementById('level-grid');
            grid.innerHTML = '';
            
            const totalLevels = 100; // Campaign size
            
            for(let i = 1; i <= totalLevels; i++) {
                const btn = document.createElement('button');
                btn.className = 'btn-level';
                
                if (i <= userProfile.currentLevel) {
                    btn.classList.add('unlocked');
                    btn.innerText = i;
                    btn.onclick = () => {
                        currentSelectedLevel = i;
                        isSinglePlayer = true;
                        gameStatus = 'racing';
                        switchPanel('hud-panel'); // Hide menu immediately
                        startRace(Math.random() + i); // Seed with level
                    };
                } else {
                    btn.classList.add('locked');
                    btn.innerHTML = `<span class="opacity-30">üîí</span>`;
                }
                
                if (i < userProfile.currentLevel) {
                    btn.classList.add('completed');
                }
                
                grid.appendChild(btn);
            }
        }

        document.getElementById('btn-mode-garage').onclick = () => {
            gameStatus = 'garage';
            switchPanel('garage-panel');
            document.getElementById('garage-layer').style.opacity = '1';
            document.getElementById('garage-layer').style.pointerEvents = 'auto';
            animateGarage();
        };

        document.getElementById('btn-mode-multi').onclick = () => {
            gameStatus = 'menu';
            isSinglePlayer = false;
            switchPanel('lobby-panel');
        };

        document.getElementById('btn-mode-solo').onclick = () => {
            renderLevelSelect();
            switchPanel('level-select-panel');
        };
        
        document.getElementById('btn-level-back').onclick = () => {
            switchPanel('menu-panel');
        };

        document.getElementById('btn-mode-shop').onclick = () => {
            document.getElementById('shop-overlay').classList.remove('hidden-panel');
        };

        document.getElementById('btn-exit-garage').onclick = async () => {
            await saveProfile();
            gameStatus = 'menu';
            document.getElementById('garage-layer').style.opacity = '0';
            document.getElementById('garage-layer').style.pointerEvents = 'none';
            document.getElementById('garage-layer').style.pointerEvents = 'none';
            switchPanel('menu-panel');
        };

        document.getElementById('btn-lobby-back').onclick = () => {
            switchPanel('menu-panel');
        };

        function switchPanel(id) {
            ['menu-panel', 'garage-panel', 'lobby-panel', 'waiting-panel', 'hud-panel', 'result-panel', 'level-select-panel'].forEach(pid => {
                const el = document.getElementById(pid);
                if (pid === id) el.classList.remove('hidden-panel');
                else el.classList.add('hidden-panel');
            });
        }

        document.getElementById('btn-upg-speed').onclick = () => buyUpgrade('speed');
        document.getElementById('btn-upg-accel').onclick = () => buyUpgrade('accel');
        document.getElementById('btn-upg-hand').onclick = () => buyUpgrade('handling');

        document.getElementById('btn-boost').onclick = tryActivateBoost;
        document.getElementById('btn-watch-ad').onclick = async () => {
            document.getElementById('ad-content').classList.add('hidden');
            document.getElementById('ad-loading').classList.remove('hidden');
            document.getElementById('ad-loading').classList.add('flex');
            
            setTimeout(async () => {
                userProfile.cash += AD_REWARD;
                await saveProfile();
                
                document.getElementById('ad-overlay').classList.add('hidden-panel');
                document.getElementById('ad-content').classList.remove('hidden');
                document.getElementById('ad-loading').classList.add('hidden');
                document.getElementById('ad-loading').classList.remove('flex');
                
                updateUI();
                alert(`Ad Complete! +$${AD_REWARD}`);
            }, 3000);
        };
        
        document.getElementById('btn-close-ad').onclick = () => {
            document.getElementById('ad-overlay').classList.add('hidden-panel');
        };

        document.getElementById('btn-close-shop').onclick = () => {
            document.getElementById('shop-overlay').classList.add('hidden-panel');
        };

        window.purchaseOffer = async function(packType) {
            const packs = {
                starter: { cash: 5000, nitro: 10, price: 4.99 },
                pro: { cash: 15000, nitro: 30, price: 9.99, maxUpgrades: false },
                ultimate: { cash: 50000, nitro: 100, price: 19.99, maxUpgrades: true, level: 50 },
                nitro: { cash: 0, nitro: 50, price: 1.99 }
            };
            
            const pack = packs[packType];
            
            if(!confirm(`Purchase ${packType.toUpperCase()} pack for $${pack.price}?\n\n(This is a demo - no real payment)`)) return;
            
            userProfile.cash += pack.cash;
            userProfile.nitroStock += pack.nitro;
            
            if(pack.maxUpgrades) {
                userProfile.stats.speed = 10;
                userProfile.stats.accel = 10;
                userProfile.stats.handling = 10;
            }
            
            if(pack.level) {
                userProfile.currentLevel = Math.min(pack.level, 100);
            }
            
            await saveProfile();
            updateUI();
            
            document.getElementById('shop-overlay').classList.add('hidden-panel');
            
            alert(`Purchase successful! Enjoy your rewards!\n\nüí∞ Cash: +$${pack.cash}\n‚ö° Nitro: +${pack.nitro}`);
        };

        // ==========================================
        // 6. MULTIPLAYER LOGIC
        // ==========================================

        document.getElementById('tab-create').onclick = () => {
            document.getElementById('view-create').classList.remove('hidden');
            document.getElementById('view-join').classList.add('hidden');
            document.getElementById('tab-create').classList.add('border-red-600', 'bg-gray-800');
            document.getElementById('tab-create').classList.remove('border-gray-700', 'bg-gray-900');
            document.getElementById('tab-join').classList.remove('border-red-600', 'bg-gray-800');
            document.getElementById('tab-join').classList.add('border-gray-700', 'bg-gray-900');
        };

        document.getElementById('tab-join').onclick = () => {
            document.getElementById('view-create').classList.add('hidden');
            document.getElementById('view-join').classList.remove('hidden');
            document.getElementById('tab-join').classList.add('border-red-600', 'bg-gray-800');
            document.getElementById('tab-join').classList.remove('border-gray-700', 'bg-gray-900');
            document.getElementById('tab-create').classList.remove('border-red-600', 'bg-gray-800');
            document.getElementById('tab-create').classList.add('border-gray-700', 'bg-gray-900');
        };

        document.getElementById('btn-create-room').onclick = async () => {
            const roomCode = Math.floor(1000 + Math.random() * 9000).toString();
            currentRoomId = roomCode;
            isHost = true;
            isSinglePlayer = false;
            
            const roomData = {
                host: userProfile.uid,
                status: 'waiting',
                created: serverTimestamp(),
                seed: Math.random(),
                players: {
                    [userProfile.uid]: {
                        name: userProfile.name,
                        color: userProfile.color,
                        stats: userProfile.stats,
                        x: 0, z: 0, speed: 0, finished: false
                    }
                }
            };

            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'rooms', roomCode), roomData);
            enterWaitingRoom();
        };

        document.getElementById('btn-join-room').onclick = async () => {
            const code = document.getElementById('input-room-code').value;
            if (code.length !== 4) return alert("Invalid Code");
            currentRoomId = code;
            isHost = false;
            isSinglePlayer = false;

            const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', code);
            const snap = await getDoc(roomRef);
            if (!snap.exists()) return alert("Room not found");

            await updateDoc(roomRef, {
                [`players.${userProfile.uid}`]: {
                    name: userProfile.name,
                    color: userProfile.color,
                    stats: userProfile.stats,
                    x: 0, z: 0, speed: 0, finished: false
                }
            });
            enterWaitingRoom();
        };

        function enterWaitingRoom() {
            switchPanel('waiting-panel');
            document.getElementById('display-room-code').innerText = currentRoomId;
            document.getElementById('host-controls').style.display = isHost ? 'block' : 'none';
            document.getElementById('guest-controls').style.display = isHost ? 'none' : 'block';

            roomUnsubscribe = onSnapshot(doc(db, 'artifacts', appId, 'public', 'data', 'rooms', currentRoomId), (snap) => {
                if (!snap.exists()) {
                    alert("Room closed");
                    location.reload();
                    return;
                }
                const data = snap.data();
                playersMap = data.players || {};
                
                const list = document.getElementById('player-list');
                list.innerHTML = '';
                Object.values(playersMap).forEach(p => {
                    const div = document.createElement('div');
                    div.className = "flex items-center justify-between bg-gray-800 p-3 rounded border border-gray-700";
                    div.innerHTML = `<div class="flex items-center gap-3">
                        <div class="w-6 h-6 rounded shadow" style="background:${p.color}"></div>
                        <span class="text-white font-bold">${p.name}</span>
                    </div>`;
                    list.appendChild(div);
                });

                if ((gameStatus === 'menu' || gameStatus === 'garage') && data.status === 'racing') {
                    startRace(data.seed);
                }
            }, (err) => console.log(err));
        }

        document.getElementById('btn-start-race').onclick = async () => {
            if (!isHost) return;
            await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'rooms', currentRoomId), { status: 'racing' });
        };

        // ==========================================
        // 7. TRACK GENERATION & PHYSICS FIXES
        // ==========================================

        function generateTrack(seed) {
            trackGroup = new THREE.Group();
            obstacles = [];
            trackPath = [];
            
            const rng = mulberry32(Math.floor(seed * 1000));
            // Ensure higher levels are harder/longer
            const diffMultiplier = isSinglePlayer ? (currentSelectedLevel * 0.1) : (userProfile.currentLevel * 0.1);
            const trackLength = 3000 + (diffMultiplier * 1000);
            
            // Generate path points first
            let points = [];
            let currentX = 0;
            let currentZ = 0;
            let currentAngle = 0;
            let segmentLength = 50; 
            
            const totalSegments = Math.floor(trackLength / segmentLength);
            
            for(let i = 0; i <= totalSegments; i++) {
                points.push({ x: currentX, z: currentZ, angle: currentAngle });
                
                // Curve logic
                if(i > 5 && i < totalSegments - 5 && rng() < 0.1) {
                    const curveStrength = (rng() - 0.5) * 0.4;
                    const duration = 10 + Math.floor(rng() * 20);
                    for(let k=0; k<duration && i<totalSegments; k++) {
                        currentAngle += curveStrength * 0.1;
                        currentAngle = Math.max(-1.2, Math.min(1.2, currentAngle));
                        
                        currentZ += Math.cos(currentAngle) * segmentLength;
                        currentX += Math.sin(currentAngle) * segmentLength;
                        
                        points.push({ x: currentX, z: currentZ, angle: currentAngle });
                        i++;
                    }
                } else {
                    currentZ += Math.cos(currentAngle) * segmentLength;
                    currentX += Math.sin(currentAngle) * segmentLength;
                }
            }
            
            trackPath = points;
            window.FINISH_Z = points[points.length-1].z;

            // Build Geometry connecting points
            for(let i = 0; i < points.length - 1; i++) {
                const p1 = points[i];
                const p2 = points[i+1];
                
                const dx = p2.x - p1.x;
                const dz = p2.z - p1.z;
                const dist = Math.sqrt(dx*dx + dz*dz);
                const angle = Math.atan2(dx, dz);
                
                const roadGeo = new THREE.PlaneGeometry(TRACK_W, dist + 1); // +1 overlap
                const roadMat = new THREE.MeshPhongMaterial({ color: 0x2a2a2a });
                const road = new THREE.Mesh(roadGeo, roadMat);
                
                road.position.set((p1.x + p2.x)/2, 0, (p1.z + p2.z)/2);
                road.rotation.x = -Math.PI/2;
                road.rotation.z = -angle; // Planar rotation
                road.receiveShadow = true;
                trackGroup.add(road);
                
                // Walls
                const barrierGeo = new THREE.BoxGeometry(1, 4, dist + 1);
                const barrierMat = new THREE.MeshStandardMaterial({ color: 0xdd0000 });
                const leftWall = new THREE.Mesh(barrierGeo, barrierMat);
                const rightWall = new THREE.Mesh(barrierGeo, barrierMat);
                
                const offsetX = Math.cos(angle) * (TRACK_W/2 + 1);
                const offsetZ = -Math.sin(angle) * (TRACK_W/2 + 1);
                
                leftWall.position.set(road.position.x - offsetX, 2, road.position.z - offsetZ);
                leftWall.rotation.y = angle;
                
                rightWall.position.set(road.position.x + offsetX, 2, road.position.z + offsetZ);
                rightWall.rotation.y = angle;
                
                trackGroup.add(leftWall);
                trackGroup.add(rightWall);
                
                // Obstacles
                if(i > 10 && i < points.length - 10 && rng() < 0.2) {
                    const obsType = Math.floor(rng() * 3);
                    let mesh;
                    if(obsType === 0) mesh = new THREE.Mesh(new THREE.BoxGeometry(4,4,4), new THREE.MeshStandardMaterial({color: 0xffaa00}));
                    else if(obsType === 1) mesh = new THREE.Mesh(new THREE.CylinderGeometry(2,2,4), new THREE.MeshStandardMaterial({color: 0x00aaff}));
                    else mesh = new THREE.Mesh(new THREE.ConeGeometry(2,5), new THREE.MeshStandardMaterial({color: 0xff00ff}));
                    
                    const laneOffset = (rng() - 0.5) * (TRACK_W - 10);
                    const obsX = road.position.x + Math.cos(angle) * laneOffset;
                    const obsZ = road.position.z - Math.sin(angle) * laneOffset;
                    
                    mesh.position.set(obsX, 2, obsZ);
                    mesh.castShadow = true;
                    trackGroup.add(mesh);
                    obstacles.push({ mesh, position: mesh.position, radius: 3 });
                }
            }
            
            // Finish Line
            const lastP = points[points.length-1];
            const finish = new THREE.Mesh(new THREE.BoxGeometry(TRACK_W + 10, 1, 5), new THREE.MeshBasicMaterial({color: 0xffffff}));
            finish.position.set(lastP.x, 0, lastP.z);
            finish.rotation.y = lastP.angle;
            trackGroup.add(finish);

            scene.add(trackGroup);
        }

        function getTrackInfo(z) {
            if(!trackPath || trackPath.length === 0) return { x: 0, angle: 0 };
            
            let idx = trackPath.findIndex(p => p.z > z);
            if(idx === -1) idx = trackPath.length - 1;
            if(idx === 0) idx = 1;
            
            const p2 = trackPath[idx];
            const p1 = trackPath[idx-1];
            
            const t = (z - p1.z) / (p2.z - p1.z);
            const x = p1.x + t * (p2.x - p1.x); 
            const angle = p1.angle + t * (p2.angle - p1.angle);
            
            return { x, angle, p1, p2 };
        }

        // ==========================================
        // 8. GAME ENGINE
        // ==========================================

        function startRace(seed) {
            gameStatus = 'racing';
            switchPanel('hud-panel');
            updateUI();
            
            if (isSinglePlayer) {
                document.getElementById('hud-level-display').classList.remove('hidden');
                document.getElementById('current-level-hud').innerText = currentSelectedLevel;
            } else {
                document.getElementById('hud-level-display').classList.add('hidden');
            }
            carHeading = 0;
            carVelocityX = 0;
            carVelocityZ = 0;
            currentSpeed = 0;
            isRespawning = false;
            // Reset Keys
            keysPressed = { up: false, down: false, left: false, right: false };
            inputState = { holding: false, steer: 0 };
            
            clock = new THREE.Clock(); 
            opponentCars = {};
            bots = [];
            boostActive = false;
            boostCooldown = 0;
            
            phys.maxSpeed = 1.8 + (userProfile.stats.speed * 0.15); 
            phys.accel = 0.04 + (userProfile.stats.accel * 0.005);
            phys.turnSpeed = 0.6 + (userProfile.stats.handling * 0.04);

            initRace3D(seed);
            
            if (isSinglePlayer) {
                initBots(4); 
            }

            const cd = document.getElementById('countdown-overlay');
            const txt = document.getElementById('countdown-text');
            cd.classList.remove('hidden');
            let count = 3;
            
            const intv = setInterval(() => {
                count--;
                if (count > 0) txt.innerText = count;
                else if (count === 0) txt.innerText = "GO!";
                else {
                    clearInterval(intv);
                    cd.classList.add('hidden');
                    startGameLoop();
                }
            }, 1000);
        }

        function initBots(count) {
            bots = [];
            const botColors = ['#ffaa00', '#00ffaa', '#aa00ff', '#ffffff', '#0099ff'];
            const playerMaxSpeed = phys.maxSpeed;
            const botSpeedReduction = 0.70;
            
            for(let i=0; i<count; i++) {
                const speedVariation = 0.9 + (Math.random() * 0.15);
                const offset = (i+1) * 3 * (i%2===0?1:-1);
                
                bots.push({
                    id: `bot_${i}`,
                    name: `AI-${i+1}`,
                    color: botColors[i % botColors.length],
                    x: offset,
                    z: -10 - (i * 5),
                    speed: 0,
                    maxSpeed: playerMaxSpeed * botSpeedReduction * speedVariation,
                    accel: phys.accel * 0.85,
                    laneOffset: offset, 
                    currentLaneOffset: offset
                });
            }
            
            bots.forEach(bot => {
                const op = createDetailedCar(bot.color);
                op.position.set(bot.x, 0, bot.z);
                scene.add(op);
                opponentCars[bot.id] = op;
            });
            
            playersMap = {};
            playersMap[userProfile.uid] = { z: 0 };
            bots.forEach(b => {
                playersMap[b.id] = { z: b.z };
            });
        }

        let keydownHandler, keyupHandler, touchstartHandler, touchendHandler, touchmoveHandler;

        function removeInputListeners() {
            if (keydownHandler) window.removeEventListener('keydown', keydownHandler);
            if (keyupHandler) window.removeEventListener('keyup', keyupHandler);
            if (touchstartHandler) document.body.removeEventListener('touchstart', touchstartHandler);
            if (touchendHandler) document.body.removeEventListener('touchend', touchendHandler);
            if (touchmoveHandler) document.body.removeEventListener('touchmove', touchmoveHandler);
        }
        
        // Revised Input Handling Logic
        function updateInputState() {
            inputState.holding = keysPressed.up;
            // Determine steering based on holding both or one
            if (keysPressed.left && keysPressed.right) {
                inputState.steer = 0; 
            } else if (keysPressed.left) {
                inputState.steer = 1;
            } else if (keysPressed.right) {
                inputState.steer = -1;
            } else {
                inputState.steer = 0;
            }
        }

       function initRace3D(seed) {
            const container = document.getElementById('game-layer');
            if (renderer) {
                renderer.dispose();
                renderer.forceContextLoss();
                renderer = null;
            }
            container.innerHTML = '';
            if (scene) scene.clear();
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.FogExp2(0x1a1a2e, 0.002);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, -15);
            camera.lookAt(0, 0, 10);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 10;
            dirLight.shadow.camera.far = 500;
            dirLight.shadow.camera.left = -100;
            dirLight.shadow.camera.right = 100;
            dirLight.shadow.camera.top = 100;
            dirLight.shadow.camera.bottom = -100;
            scene.add(dirLight);
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));

            generateTrack(seed);

            myCar = createDetailedCar(userProfile.color);
            scene.add(myCar);

            if (!isSinglePlayer) {
                Object.entries(playersMap).forEach(([uid, p]) => {
                    if (uid !== userProfile.uid) {
                        const op = createDetailedCar(p.color);
                        scene.add(op);
                        opponentCars[uid] = op;
                    }
                });
            }

            removeInputListeners();
            
            // NEW KEY HANDLERS with persistent state
            keydownHandler = (e) => {
                if(e.key==='w' || e.key==='ArrowUp') keysPressed.up = true;
                if(e.key==='s' || e.key==='ArrowDown') keysPressed.down = true;
                if(e.key==='a' || e.key==='ArrowLeft') keysPressed.left = true;
                if(e.key==='d' || e.key==='ArrowRight') keysPressed.right = true;
                if(e.key===' ' || e.key==='Shift') tryActivateBoost();
                updateInputState();
            };
            
            keyupHandler = (e) => {
                if(e.key==='w' || e.key==='ArrowUp') keysPressed.up = false;
                if(e.key==='s' || e.key==='ArrowDown') keysPressed.down = false;
                if(e.key==='a' || e.key==='ArrowLeft') keysPressed.left = false;
                if(e.key==='d' || e.key==='ArrowRight') keysPressed.right = false;
                updateInputState();
            };
            
            window.addEventListener('keydown', keydownHandler);
            window.addEventListener('keyup', keyupHandler);

            // Reverse Button Setup
            const reverseBtn = document.getElementById('btn-reverse');
            if (reverseBtn) {
                reverseBtn.onpointerdown = (e) => {
                    e.preventDefault();
                    reverseBtn.classList.add('pedal-active');
                    keysPressed.down = true;
                    updateInputState();
                };
                reverseBtn.onpointerup = (e) => {
                    e.preventDefault();
                    reverseBtn.classList.remove('pedal-active');
                    keysPressed.down = false;
                    updateInputState();
                };
                reverseBtn.onpointerleave = () => {
                    reverseBtn.classList.remove('pedal-active');
                    keysPressed.down = false;
                    updateInputState();
                };
            }

            // TOUCH HANDLERS
            touchstartHandler = (e) => { 
                // Only count taps not on buttons as acceleration
                if (e.target.tagName !== 'BUTTON' && !e.target.closest('button')) {
                    inputState.holding = true;
                    if (e.touches.length === 2) tryActivateBoost();
                }
            };

            touchendHandler = (e) => { 
                inputState.holding = false; 
            };
            
            touchmoveHandler = (e) => {
                const x = e.touches[0].clientX;
                const mid = window.innerWidth / 2;
                inputState.steer = (mid - x) / (mid/2);
                if (inputState.steer > 1) inputState.steer = 1;
                if (inputState.steer < -1) inputState.steer = -1;
            };
            
            document.body.addEventListener('touchstart', touchstartHandler);
            document.body.addEventListener('touchend', touchendHandler);
            document.body.addEventListener('touchmove', touchmoveHandler);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        async function tryActivateBoost() {
            if (boostActive || boostCooldown > 0 || isRespawning) return;

            if (userProfile.nitroStock > 0) {
                userProfile.nitroStock--;
                await saveProfile();
                updateUI();
                activateBoostEffect();
            } else {
                if (userProfile.cash >= BOOST_COST) {
                    userProfile.cash -= BOOST_COST;
                    userProfile.nitroStock = 2;
                    await saveProfile();
                    updateUI();
                    activateBoostEffect();
                } else {
                    document.getElementById('ad-overlay').classList.remove('hidden-panel');
                }
            }
        }

        function activateBoostEffect() {
            boostActive = true;
            boostCooldown = BOOST_DURATION;
            currentSpeed = Math.min(currentSpeed * 1.5, phys.maxSpeed * BOOST_MULTIPLIER);
            
            const bar = document.getElementById('boost-bar');
            bar.classList.remove('from-red-500');
            bar.classList.add('from-cyan-400', 'to-white');
        }

        function updateBots() {
            bots.forEach(bot => {
                // Bots accelerate
                if (bot.speed < bot.maxSpeed) {
                    bot.speed += bot.accel;
                }
                
                const trackInfo = getTrackInfo(bot.z);
                const idealX = trackInfo.x + bot.laneOffset;
                
                // Steer towards ideal lane
                const diff = idealX - bot.x;
                if(Math.abs(diff) > 0.5) {
                    bot.x += Math.sign(diff) * 0.3;
                }
                
                // Obstacle avoidance
                for(let obs of obstacles) {
                    const dx = bot.x - obs.position.x;
                    const dz = bot.z - obs.position.z;
                    const dist = Math.sqrt(dx*dx + dz*dz);
                    
                    if(dz > -15 && dz < 20 && dist < obs.radius + 4) {
                        bot.x += Math.sign(dx) * 0.6;
                    }
                }
                
                // Boundary checks relative to track center
                const boundary = (TRACK_W/2) - 2;
                const offsetFromTrack = bot.x - trackInfo.x;
                
                if(offsetFromTrack > boundary) bot.x = trackInfo.x + boundary;
                if(offsetFromTrack < -boundary) bot.x = trackInfo.x - boundary;
                
                bot.z += bot.speed * 2.5;
                
                // Update Mesh Position & Rotation
                if (opponentCars[bot.id]) {
                    opponentCars[bot.id].position.set(bot.x, 0, bot.z);
                    opponentCars[bot.id].rotation.y = -trackInfo.angle; 
                }
                
                if(playersMap[bot.id]) {
                    playersMap[bot.id].z = bot.z;
                }
            });
        }

        function startGameLoop() {
            let lastSync = 0;
            
            function loop() {
                if (gameStatus !== 'racing') return;
                requestAnimationFrame(loop);
                
                let targetAccel = phys.accel;
                let targetMaxSpeed = phys.maxSpeed;
                
                if (boostCooldown > 0) {
                    boostCooldown--;
                    if (boostActive) {
                        targetMaxSpeed *= BOOST_MULTIPLIER;
                        targetAccel *= 3.0; 
                        if (currentSpeed < phys.maxSpeed * BOOST_MULTIPLIER) {
                            currentSpeed += targetAccel * 2;
                        }
                    }
                    if (boostCooldown <= 0) {
                        boostActive = false;
                        if (currentSpeed > phys.maxSpeed) currentSpeed = phys.maxSpeed;
                        const bar = document.getElementById('boost-bar');
                        if(bar) {
                            bar.classList.add('from-red-500');
                            bar.classList.remove('from-cyan-400', 'to-white');
                        }
                    }
                }
                
                const trackInfo = getTrackInfo(myCar.position.z);
                
                if (!isRespawning) {
                    // ACCELERATION
                    if (inputState.holding || keysPressed.up) {
                        const speedRatio = currentSpeed / targetMaxSpeed;
                        const torqueCurve = Math.max(0.2, 1.0 - Math.pow(speedRatio, 2)); 
                        currentSpeed += (targetAccel * 2.5) * torqueCurve;
                    } else if (keysPressed.down) {
                        // REVERSE
                        currentSpeed -= targetAccel * 1.5;
                        if (currentSpeed < -targetMaxSpeed * 0.5) currentSpeed = -targetMaxSpeed * 0.5;
                    } else {
                        currentSpeed *= 0.97;
                    }
                    
                    if (currentSpeed > targetMaxSpeed) currentSpeed = targetMaxSpeed;
                    
                    // STEERING - Turn the car's heading based on speed and input
                    if (Math.abs(currentSpeed) > 0.05) {
                        // More responsive turning at lower speeds, tighter at high speeds
                        const turnRate = phys.turnSpeed * (1.0 + (1.0 - Math.abs(currentSpeed) / phys.maxSpeed) * 0.5);
                        // Reverse steering if moving backwards
                        const directionMult = currentSpeed > 0 ? 1 : -1;
                        const steerInput = inputState.steer * 0.02 * turnRate * directionMult;
                        carHeading += steerInput;
                    }
                    
                    // TRACK ALIGNMENT - Gradually align car with track direction
                    const trackAngleDiff = -trackInfo.angle - carHeading;
                    
                    // Normalize angle difference to -PI to PI
                    let normalizedDiff = trackAngleDiff;
                    while (normalizedDiff > Math.PI) normalizedDiff -= Math.PI * 2;
                    while (normalizedDiff < -Math.PI) normalizedDiff += Math.PI * 2;
                    
                    // Gentle automatic alignment when not steering hard
                    const alignmentStrength = Math.abs(inputState.steer) < 0.3 ? 0.03 : 0.01;
                    // Only align if moving forward
                    if (currentSpeed > 0.1) {
                         carHeading += normalizedDiff * alignmentStrength * (currentSpeed / phys.maxSpeed);
                    }
                   
                    
                    // VELOCITY CALCULATION - Move in the direction the car is facing
                    const moveSpeed = currentSpeed * 2.5;
                    carVelocityX = Math.sin(carHeading) * moveSpeed;
                    carVelocityZ = Math.cos(carHeading) * moveSpeed;
                    
                    // DRIFT/SLIP - Add lateral drift when turning hard
                    const driftFactor = Math.abs(inputState.steer) * currentSpeed * 0.15;
                    const driftX = Math.cos(carHeading) * driftFactor * -Math.sign(inputState.steer);
                    const driftZ = Math.sin(carHeading) * driftFactor * Math.sign(inputState.steer);
                    
                    // Apply movement
                    myCar.position.x += carVelocityX + driftX;
                    myCar.position.z += carVelocityZ + driftZ;
                    
                    // TRACK CENTERING ASSIST - Push car back toward track center when off course
                    // Only apply if not colliding
                    const currentOffset = myCar.position.x - trackInfo.x;
                    const centeringForce = -currentOffset * 0.02 * (currentSpeed / phys.maxSpeed);
                    myCar.position.x += centeringForce;
                    
                    // ROTATION - Visual rotation matches heading plus steering lean
                    myCar.rotation.y = carHeading;
                    myCar.rotation.z = -inputState.steer * 0.2 * (currentSpeed / phys.maxSpeed); // Lean into turns
                    
                    // ==========================================
                    //  PHYSICS FIX: IMPROVED WALL COLLISION (Slide & Bounce)
                    // ==========================================
                    const boundaryLimit = (TRACK_W / 2) - 2;
                    
                    if (Math.abs(currentOffset) > boundaryLimit) {
                        // 1. Stick/Clamp to Wall (Prevent passing through)
                        myCar.position.x = trackInfo.x + (Math.sign(currentOffset) * boundaryLimit);

                        // 2. Determine Impact Angle
                        // Track tangent angle is -trackInfo.angle (based on previous logic)
                        const wallTangent = -trackInfo.angle;
                        let relativeAngle = carHeading - wallTangent;
                        // Normalize to -PI to PI
                        while (relativeAngle > Math.PI) relativeAngle -= Math.PI * 2;
                        while (relativeAngle < -Math.PI) relativeAngle += Math.PI * 2;
                        
                        // Check if we are actually facing INTO the wall
                        // Right Wall (Offset > 0): Facing into if relativeAngle > 0 (Right Turn)
                        // Left Wall (Offset < 0): Facing into if relativeAngle < 0 (Left Turn)
                        const isFacingWall = (currentOffset > 0 && relativeAngle > 0) || (currentOffset < 0 && relativeAngle < 0);

                        if (isFacingWall) {
                            const impactSeverity = Math.abs(relativeAngle);
                            
                            // 3. BOUNCE vs SLIDE Logic
                            if (impactSeverity > 0.8) { 
                                // STEEP IMPACT (Crash) -> Bounce Back
                                carHeading = (2 * wallTangent) - carHeading; // Reflect angle
                                currentSpeed *= 0.5; // Massive speed loss
                                
                                // Visual Shock
                                camera.position.y -= 0.5;
                                renderer.domElement.style.filter = 'brightness(1.5)';
                                setTimeout(() => renderer.domElement.style.filter = 'none', 50);
                            } else {
                                // SHALLOW IMPACT (Drive on it) -> Slide/Grind
                                // Force align heading with wall (remove perpendicular velocity)
                                // We interpolate quickly to the wall tangent to simulate the car body aligning with the wall
                                carHeading = wallTangent; 
                                
                                // Friction (Grinding paint)
                                currentSpeed *= 0.97; 
                            }
                        }
                    }
                    
                    // ==========================================
                    //  PHYSICS FIX: BOT COLLISION (Mutual Slowdown & Bounce)
                    // ==========================================
                    if (isSinglePlayer && bots.length > 0) {
                        bots.forEach(bot => {
                            const dx = myCar.position.x - bot.x;
                            const dz = myCar.position.z - bot.z;
                            const dist = Math.sqrt(dx*dx + dz*dz);
                            const minDist = 3.5; // Car size

                            if (dist < minDist) {
                                // 1. Separate (Push Apart)
                                const nx = dx / dist;
                                const nz = dz / dist;
                                const overlap = minDist - dist;
                                
                                myCar.position.x += nx * overlap * 0.5;
                                myCar.position.z += nz * overlap * 0.5;
                                bot.x -= nx * overlap * 0.5;
                                bot.z -= nz * overlap * 0.5;

                                // 2. Mutual Speed Penalty (Impact)
                                currentSpeed *= 0.8;
                                bot.speed *= 0.8;
                                
                                // 3. "Sometimes Bounce Back" Logic
                                // If hitting head-on or very fast relative speed
                                const relativeSpeed = currentSpeed - bot.speed;
                                if (Math.abs(relativeSpeed) > 0.8) {
                                    // Heavy impact bounce
                                    currentSpeed = -currentSpeed * 0.4; // Reverse player direction partially
                                    bot.speed += Math.abs(currentSpeed) * 0.5; // Push bot forward
                                    
                                    // Visual flash
                                    renderer.domElement.style.filter = 'sepia(1) hue-rotate(-50deg)';
                                    setTimeout(() => { renderer.domElement.style.filter = 'none'; }, 100);
                                }
                            }
                        });
                    }
                    
                    // OBSTACLE COLLISION (Static objects)
                    for (let obs of obstacles) {
                        const dx = myCar.position.x - obs.position.x;
                        const dz = myCar.position.z - obs.position.z;
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        const collisionDist = obs.radius + 2.0;
                        
                        if (distance < collisionDist) {
                            const pushX = (dx / distance) || 0;
                            const pushZ = (dz / distance) || 0;
                            myCar.position.x += pushX * 2;
                            myCar.position.z += pushZ * 2;
                            currentSpeed *= 0.1; // Full stop on big obstacles
                            
                            renderer.domElement.style.filter = 'brightness(2) sepia(1)';
                            setTimeout(() => { renderer.domElement.style.filter = 'none'; }, 100);
                            break;
                        }
                    }
                }
                
                // CAMERA - follows car heading
                const camDist = 18;
                const camHeight = 10 + (Math.abs(currentSpeed) * 2);

                const desiredCamX = myCar.position.x - (Math.sin(carHeading) * camDist);
                const desiredCamZ = myCar.position.z - (Math.cos(carHeading) * camDist);

                camera.position.x += (desiredCamX - camera.position.x) * 0.1;
                camera.position.z += (desiredCamZ - camera.position.z) * 0.1;
                camera.position.y += (camHeight - camera.position.y) * 0.05;

                const lookAheadZ = myCar.position.z + (Math.cos(carHeading) * 30);
                const lookAheadX = myCar.position.x + (Math.sin(carHeading) * 30);
                camera.lookAt(lookAheadX, 0, lookAheadZ);
                
                // HUD
                const speedKmh = Math.floor(currentSpeed * 120);
                const speedEl = document.getElementById('hud-speed');
                if(speedEl) speedEl.innerText = speedKmh;
                
                if (isSinglePlayer) {
                    updateBots();
                    if(playersMap[userProfile.uid]) {
                        playersMap[userProfile.uid].z = myCar.position.z;
                    }
                } else {
                    if (Date.now() - lastSync > 100) {
                        lastSync = Date.now();
                        if(currentRoomId) {
                            const rRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', currentRoomId);
                            updateDoc(rRef, {
                                [`players.${userProfile.uid}.x`]: Number(myCar.position.x.toFixed(2)),
                                [`players.${userProfile.uid}.z`]: Number(myCar.position.z.toFixed(2)),
                            }).catch(err => console.log('Sync error:', err));
                        }
                    }
                    
                    Object.entries(playersMap).forEach(([uid, p]) => {
                        if (uid === userProfile.uid) return;
                        if (opponentCars[uid]) {
                            opponentCars[uid].position.x += (p.x - opponentCars[uid].position.x) * 0.1;
                            opponentCars[uid].position.z += (p.z - opponentCars[uid].position.z) * 0.1;
                        }
                    });
                }
                
                let rank = 1;
                Object.entries(playersMap).forEach(([uid, p]) => {
                    if (uid !== userProfile.uid && p.z > myCar.position.z) {
                        rank++;
                    }
                });
                
                const posEl = document.getElementById('hud-pos');
                if(posEl) posEl.innerText = `${rank}/${Object.keys(playersMap).length}`;
                
                const finishDistance = window.FINISH_Z || 5000;
                if (myCar.position.z >= finishDistance - 15) {
                    finishRace(rank);
                    return;
                }
                
                if (isRespawning) {
                    myCar.visible = Math.floor(Date.now() / 100) % 2 === 0;
                } else {
                    myCar.visible = true;
                }
                
                if(renderer && scene && camera) {
                    renderer.render(scene, camera);
                }
            }
            
            loop();
        }

       async function finishRace(rank) {
            gameStatus = 'finished';
            if (roomUnsubscribe) { roomUnsubscribe(); roomUnsubscribe = null; }
            
            let reward = 200;
            if (rank === 1) reward = 600;
            else if (rank === 2) reward = 500;
            else if (rank === 3) reward = 400;
            else if (rank === 4) reward = 300;

            userProfile.cash += reward;
            
            const lvlMsg = document.getElementById('level-up-msg');
            if (isSinglePlayer && rank === 1 && currentSelectedLevel === userProfile.currentLevel) {
                if (userProfile.currentLevel < 100) {
                    userProfile.currentLevel++;
                    lvlMsg.classList.remove('hidden');
                    lvlMsg.innerText = `LEVEL UP! NOW LEVEL ${userProfile.currentLevel}`;
                } else {
                    lvlMsg.classList.remove('hidden');
                    lvlMsg.innerText = `MAX LEVEL REACHED!`;
                }
            } else {
                lvlMsg.classList.add('hidden');
            }

            await saveProfile();

            document.getElementById('result-panel').classList.remove('hidden-panel');
            document.getElementById('result-pos').innerText = `#${rank}`;
            document.getElementById('result-money').innerText = reward;
        }

        function mulberry32(a) {
            return function() {
                var t = a += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }
        
        (async function init() {
            try {
                await initAuth();
                console.log("Auth initialized");
            } catch (error) {
                console.error("Fatal init error:", error);
                document.getElementById('loading-text').innerText = "Connection Failed. Refresh to retry.";
                setTimeout(() => {
                    document.getElementById('loading-panel').classList.add('hidden-panel');
                    document.getElementById('menu-panel').classList.remove('hidden-panel');
                    alert("Running in offline mode. Multiplayer disabled.");
                }, 3000);
            }
        })();

    </script>
</body>
</html>
